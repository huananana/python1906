"""__author__=桃花寓酒寓美人"""
import re

# 1.什么时正则表达式
"""
用正则符号来描述字符串规则让字符串匹配更简单的一种工具；正则本身的语法和语言无关
几乎所有的编程语言都支持正则
python通过提供re模块来支持正则表达式
"""

# value = input('请输入电话号码：')
# re = re.fullmatch(r'1[3-9]\d{9}', value)
# print(re)

# 2.正则符号
"""
1)普通字符 - 在正则表达式中没有特殊功能或者特殊意义的字符都是普通字符
普通字符在正则表达式中就代表这个符号本身，匹配的时候只能和这个指定的字符进行匹配
re_str = r''

2）. - 代表任意一个字符
re_str = r'a.b' # 匹配一个长度是3的字符串，第一个字符是a，最后一个字符是b，中间是任意字符

3）\\w - ASCII码标中只能匹配字母、数字或者下划线；ASCII码表以外的都可以匹配
re_str = r'a\\wb'

4）\\d - 匹配一个任意一个数字字符
re_str = r'a\\d\\db'

5）\\s - 匹配一个任意空白字符 （' ','\t','\n'）

6）\\W, \\D, \\S - 与小写功能相反

7）[字符集] - 匹配字符集中的任意一个字符
注意：一个[]只能匹配一个字符
注意：前六种组合放进[]里也可生效
a.[普通字符集]  例如：[abc] - 匹配a、b、c三个字符中的任意一个
b.[字符1-字符2] 例如：[0-9]
                      [a-zA-Z]
                      [\u4e00-\u9fa5]
                      [a-z0-9_]
注意：字符1的编码值必须小于字符2的编码值

8）[^字符集] - 匹配除了字符集以外的任意一个字符

"""

# 3.检测符号
# 1) \b - 检测是否是以单词结尾
"""
单词结尾 - 所有可以区分出两个不同单词的符号都是单词结尾，其中字符串开头和字符串结尾
用法：检测\b所在为止是否是单词结尾；不影响匹配的时候的字符串长度
"""
# 匹配一个长度是3的字符串，第一个字符是a，最后一个字符是b，中间是任意一个数字；并且要求b的后面是单词边界
re_str = r'a\db\b'
print(re.fullmatch(re_str, 'a7b'))

# 2)^ - 检测字符串开头
# 判断^所在的位置是否是字符串开头
re_str = r'^\d\d\d'
print(re.search(re_str, '12234dog'))

# 3) $ - 检测字符串结尾
re_str = r'\d\d\d$'
print(re.search(re_str, '123dog23446'))

# 4.匹配次数
# 1）? - 匹配0次或1次
"""
x? - x出现0次或1次
\\d? - 任意数字出现0次或1次
[a-z]? - 小写字母出现0次或1次
"""
re_str = r'ax?b'
print(re.fullmatch(re_str, 'ab'))

# 2) * - 匹配0次或多次
re_str = r'a\d*b'  # r'a\d\d...\d\db'
print(re.fullmatch(re_str, 'a32452345b'))

# 3) + - 匹配至少一次

# 4）{}
"""
{N} - 匹配N次
{M,N} - 匹配M到N次
{M,} - 匹配至少M次
{，N} - 匹配至多N次
"""
# re_str = r'a\d{5}b'  # -> a12345b

# 练习：写一个正则表达式判断输入的内容是否是数字
# 123 -》 成功！  123a  -》 失败!
re_str = r'[+-]?[1-9]\d*'
print(re.fullmatch(re_str, '123'))

# 4.贪婪和非贪婪
"""
贪婪 - 在能匹配成功的前提下，尽可能多的匹配
非贪婪 - 在能匹配成功的前提下，尽可能少的匹配
匹配次数不确定的时候有贪婪和非贪婪两种状态
? * + {M,N},{M,}{,N} - 默认是贪婪的；后面加？变非贪婪
"""
re_str = r'\d{3,5}'
print(re.search(re_str, 'abc32414324312'))
print(re.search(re_str, 'abc3242'))

# 5.分之和分组
# 1）| - 分之
"""
正则1|正则2 - 先让正则1去匹配，失败，匹配正则2；只要两个中有一个能够匹配成功就成功
"""
# 匹配三个数字或者三个字母的字符串
re_str = r'\d'

# 匹配一个字符串：abc前是3个数字或者3个字母
re_str = r'\d{3}abc|[a-zA-Z]abc'
re_str = r'(\d{3}|[a-zA-Z])abc'

# 2) () - 分组
"""
(正则表达式) - 将正则表达式看成一个整体进行操作
整体控制次数：()匹配次数
重复：带分组的正则表达式\\M  --  
"""
# ad78gf
re_str = r'[a-z]{2}\d{2}[a-z]{2}\d{2}[a-z]{2}\d{2}'
re_str = r'([a-z]{2}\d{2})+'
